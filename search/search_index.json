{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sandbox Request Service Sandbox request acts as a communication platform for Data Requesters, Data Stewards, and DAC Representatives to negotiate on a request to access a specific dataset. This service pulls in every request-relevant event and persists an event history for each request.","title":"Sandbox Request Service"},{"location":"#sandbox-request-service","text":"Sandbox request acts as a communication platform for Data Requesters, Data Stewards, and DAC Representatives to negotiate on a request to access a specific dataset. This service pulls in every request-relevant event and persists an event history for each request.","title":"Sandbox Request Service"},{"location":"installation/","text":"Setup and Installation Setting up the dev environment A Dockerfile (and docker-compose.yaml ) for a container corresponding to a development environment has been configured and made available in the .devcontainer folder. You can use the configurations in .devcontainer to run VS Code in a Docker container via the Remote Container extension for VS Code . Alternatively, you can also run the container directly from your command line as follows: # build the image first docker build -t sandbox-request:dev -f .devcontainer/Dockerfile . # run the container docker run --rm -it -u vscode -v \"${PWD}:/workspace\" sandbox-request:dev bash Running the application You can run the application in two ways, sandbox-request or, uvicorn sandbox_request.main:app --reload You can visit the API by navigating to http://localhost:8000/docs Bootstrapping the database for the application The request service relies on a MongoDB instance that keeps track of requests and their approval status. All request records are stored in the requests collection. To pre-load request records into a fresh instance of MongoDB: # load request records python scripts/populate_request_store.py --base-url http://localhost:8000 --directory examples","title":"Setup and Installation"},{"location":"installation/#setup-and-installation","text":"","title":"Setup and Installation"},{"location":"installation/#setting-up-the-dev-environment","text":"A Dockerfile (and docker-compose.yaml ) for a container corresponding to a development environment has been configured and made available in the .devcontainer folder. You can use the configurations in .devcontainer to run VS Code in a Docker container via the Remote Container extension for VS Code . Alternatively, you can also run the container directly from your command line as follows: # build the image first docker build -t sandbox-request:dev -f .devcontainer/Dockerfile . # run the container docker run --rm -it -u vscode -v \"${PWD}:/workspace\" sandbox-request:dev bash","title":"Setting up the dev environment"},{"location":"installation/#running-the-application","text":"You can run the application in two ways, sandbox-request or, uvicorn sandbox_request.main:app --reload You can visit the API by navigating to http://localhost:8000/docs","title":"Running the application"},{"location":"installation/#bootstrapping-the-database-for-the-application","text":"The request service relies on a MongoDB instance that keeps track of requests and their approval status. All request records are stored in the requests collection. To pre-load request records into a fresh instance of MongoDB: # load request records python scripts/populate_request_store.py --base-url http://localhost:8000 --directory examples","title":"Bootstrapping the database for the application"},{"location":"reference/config/","text":"API Config This module provides Configuration for the API get_config () Get the Config object that encapsulates all the configuration for this application. Source code in sandbox_request/config.py @lru_cache def get_config (): \"\"\" Get the Config object that encapsulates all the configuration for this application. \"\"\" return Config ()","title":"API Config"},{"location":"reference/config/#api-config","text":"This module provides Configuration for the API","title":"API Config"},{"location":"reference/config/#sandbox_request.config.get_config","text":"Get the Config object that encapsulates all the configuration for this application. Source code in sandbox_request/config.py @lru_cache def get_config (): \"\"\" Get the Config object that encapsulates all the configuration for this application. \"\"\" return Config ()","title":"get_config()"},{"location":"reference/core/","text":"Core methods and utilities Core functionalities of this service utils All core utilities for the functionality of Request Service API. check_dataset ( dataset_id ) async Check if the given dataset ID exists in the metadata store. Source code in sandbox_request/core/utils.py async def check_dataset ( dataset_id : str ) -> Optional [ Dict ]: \"\"\"Check if the given dataset ID exists in the metadata store.\"\"\" config = get_config () dataset = None url = f \" { config . svc_metadata_url } /datasets/ { dataset_id } \" try : response = requests . get ( url ) if response . status_code == 200 : dataset = response . json () elif response . status_code == 404 : raise HTTPException ( status_code = 404 , detail = f \"Dataset { dataset_id } could not be found in the metadata store. \" + \"Cannot create a request for a dataset that does not exist.\" , ) else : response . raise_for_status () except requests . RequestException as ex : raise HTTPException ( status_code = 502 , detail = ex . errno ) from ex return dataset","title":"Core methods and utilities"},{"location":"reference/core/#core-methods-and-utilities","text":"Core functionalities of this service","title":"Core methods and utilities"},{"location":"reference/core/#sandbox_request.core.utils","text":"All core utilities for the functionality of Request Service API.","title":"utils"},{"location":"reference/dao/","text":"Data Access Objects (DAO) Database Handling db_connect This module contains the DBConnect class and its related methods that are relevant for connecting to an underlying MongoDB store. DBConnect Class that handles connections to a MongoDB store. close_db ( self ) async Close database connection. Source code in sandbox_request/dao/db_connect.py async def close_db ( self ) -> None : \"\"\" Close database connection. \"\"\" self . client . close () get_collection ( self , name ) async Get a collection from the database. Parameters: Name Type Description Default name str Name of the collection to fetch required Returns: Type Description AsyncIOMotorCollection An instance of AsyncIOMotorCollection Source code in sandbox_request/dao/db_connect.py async def get_collection ( self , name : str ) -> AsyncIOMotorCollection : \"\"\" Get a collection from the database. Args: name: Name of the collection to fetch Returns: An instance of AsyncIOMotorCollection \"\"\" client = await self . get_db () collection = client [ self . db_name ][ name ] return collection get_db ( self ) async Return database client instance. Returns: Type Description AsyncIOMotorClient An instance of AsyncIOMotorClient Source code in sandbox_request/dao/db_connect.py async def get_db ( self ) -> AsyncIOMotorClient : \"\"\" Return database client instance. Returns: An instance of AsyncIOMotorClient \"\"\" self . client = AsyncIOMotorClient ( self . db_url ) return self . client request Convenience methods for retrieving, adding, updating, and deleting requests from the database. add_request ( data ) async Add a new request object to the database. Parameters: Name Type Description Default data RequestInit The request object required Returns: Type Description Request The added request object Source code in sandbox_request/dao/request.py async def add_request ( data : RequestInit ) -> Request : \"\"\" Add a new request object to the database. Args: data: The request object Returns: The added request object \"\"\" db_connect = DBConnect () collection = await db_connect . get_collection ( name = COLLECTION_NAME ) request_id = await get_next_request_id ( COUNTER , COLLECTION_NAME ) # supplement missing attributes: data_dict = data . dict () data_dict [ \"id\" ] = request_id data_dict [ \"status\" ] = StatusEnum . PENDING # validate final Request object: request = Request ( ** data_dict ) await collection . insert_one ( request . dict ()) # type: ignore await db_connect . close_db () request = await get_request ( request_id ) # type: ignore return request delete_request ( request_id ) async Delete a request from the database. Parameters: Name Type Description Default request_id str The ID of ther request that is to be deleted. required Source code in sandbox_request/dao/request.py async def delete_request ( request_id : str ) -> None : \"\"\" Delete a request from the database. Args: request_id: The ID of ther request that is to be deleted. \"\"\" db_connect = DBConnect () collection = await db_connect . get_collection ( name = COLLECTION_NAME ) collection . delete_one ({ \"id\" : request_id }) # type: ignore await db_connect . close_db () get_all_requests () async Retrieve a list of all requests from the database. Returns: Type Description List[sandbox_request.models.Request] List of Requests Source code in sandbox_request/dao/request.py async def get_all_requests () -> List [ Request ]: \"\"\" Retrieve a list of all requests from the database. Returns: List of Requests \"\"\" db_connect = DBConnect () collection = await db_connect . get_collection ( name = COLLECTION_NAME ) request_dicts = await collection . find () . to_list ( None ) # type: ignore requests = [ Request ( ** request_dict ) for request_dict in request_dicts ] await db_connect . close_db () return requests get_next_request_id ( counter_name , collection_name ) async This method generates the sequence ID for the MongoDB document. Parameters: Name Type Description Default counter_name str Name of the counter collection required collection_name str Name of the collection for which the ID is to be generated required Returns: Type Description str The generated ID Source code in sandbox_request/dao/request.py async def get_next_request_id ( counter_name : str , collection_name : str ) -> str : \"\"\" This method generates the sequence ID for the MongoDB document. Args: counter_name: Name of the counter collection collection_name: Name of the collection for which the ID is to be generated Returns: The generated ID \"\"\" db_connect = DBConnect () await _check_collection_counter () collection = await db_connect . get_collection ( name = counter_name ) document = await collection . find_one ({ \"_id\" : collection_name }) # type: ignore collection . update_one ({ \"_id\" : collection_name }, { \"$inc\" : { \"value\" : 1 }}) # type: ignore await db_connect . close_db () return f \"REQ: { ( document [ 'value' ] + 1 ) : 07 } \" get_request ( request_id ) async Given a request ID, get the request object from the database. Parameters: Name Type Description Default request_id str The request ID required Returns: Type Description Request The request object Source code in sandbox_request/dao/request.py async def get_request ( request_id : str ) -> Request : \"\"\" Given a request ID, get the request object from the database. Args: request_id: The request ID Returns: The request object \"\"\" db_connect = DBConnect () collection = await db_connect . get_collection ( name = COLLECTION_NAME ) request_dict = await collection . find_one ({ \"id\" : request_id }) # type: ignore request = Request ( ** request_dict ) await db_connect . close_db () return request update_request ( request_id , data ) async Given a request ID and data, update the request object in the database. Parameters: Name Type Description Default request_id str The request ID required data Union[sandbox_request.models.Request, sandbox_request.models.RequestPartial] The request object required Returns: Type Description Request The updated request object Source code in sandbox_request/dao/request.py async def update_request ( request_id : str , data : Union [ Request , RequestPartial ] ) -> Request : \"\"\" Given a request ID and data, update the request object in the database. Args: request_id: The request ID data: The request object Returns: The updated request object \"\"\" db_connect = DBConnect () collection = await db_connect . get_collection ( name = COLLECTION_NAME ) if data . status == StatusEnum . REJECTED or data . status == StatusEnum . APPROVED : collection . update_one ( # type: ignore { \"id\" : request_id }, { \"$set\" : data . dict ( exclude_unset = True )} ) await db_connect . close_db () request = await get_request ( request_id ) # type: ignore return request","title":"Data Access Objects (DAO)"},{"location":"reference/dao/#data-access-objects-dao","text":"Database Handling","title":"Data Access Objects (DAO)"},{"location":"reference/dao/#sandbox_request.dao.db_connect","text":"This module contains the DBConnect class and its related methods that are relevant for connecting to an underlying MongoDB store.","title":"db_connect"},{"location":"reference/dao/#sandbox_request.dao.request","text":"Convenience methods for retrieving, adding, updating, and deleting requests from the database.","title":"request"},{"location":"reference/models/","text":"Models This module contains Pydantic models used by the Request Service API. Request pydantic-model Class Request Config Class config to allow the usage of Enum for Status in Request class RequestInit pydantic-model Model containing attributes required for the creation of a new Request (POST against the API). RequestPartial pydantic-model Class Request for partial updates (PATCH). Only a subset of attributes of Request can be modified. Config Class config to allow the usage of Enum for Status in Request class StatusEnum Class StatusEnum for enumerating the possible statuses","title":"Models"},{"location":"reference/models/#models","text":"This module contains Pydantic models used by the Request Service API.","title":"Models"},{"location":"reference/models/#sandbox_request.models.Request","text":"Class Request","title":"Request"},{"location":"reference/models/#sandbox_request.models.RequestInit","text":"Model containing attributes required for the creation of a new Request (POST against the API).","title":"RequestInit"},{"location":"reference/models/#sandbox_request.models.RequestPartial","text":"Class Request for partial updates (PATCH). Only a subset of attributes of Request can be modified.","title":"RequestPartial"},{"location":"reference/models/#sandbox_request.models.StatusEnum","text":"Class StatusEnum for enumerating the possible statuses","title":"StatusEnum"},{"location":"reference/routes/","text":"API routes This package defines routes/endpoints of the Restful API health Health endpoint to check the health of the API get_health () async Check health of service. Source code in sandbox_request/routes/health.py @health_router . get ( \"/health\" , summary = \"Check health of service\" ) async def get_health (): \"\"\" Check health of service. \"\"\" return { \"status\" : \"OK\" } requests All routes for interacting with Data Requests. add_requests ( data , config = Depends ( get_config )) async Add a new Request. Source code in sandbox_request/routes/requests.py @request_router . post ( \"/requests\" , response_model = Request ) async def add_requests ( data : RequestInit , config = Depends ( get_config )): \"\"\" Add a new Request. \"\"\" dataset_id = data . dataset_id await check_dataset ( dataset_id ) request = await add_request ( data ) send_notification ( recipient_name = config . data_steward_name , recipient_email = config . data_steward_email , subject = f \"New Request Created: { request . id } \" , message_text = ( f \"User { request . user_id } created a new request { request . id } \" f \"to access dataset { request . dataset_id } .\" ), ) return request delete_requests ( request_id , config = Depends ( get_config )) async Delete a Request object based on Request ID. Source code in sandbox_request/routes/requests.py @request_router . delete ( \"/requests/ {request_id} \" , response_model = Request ) async def delete_requests ( request_id , config = Depends ( get_config )): \"\"\" Delete a Request object based on Request ID. \"\"\" await delete_request ( request_id ) send_notification ( recipient_name = config . data_steward_name , recipient_email = config . data_steward_email , subject = f \"Request Updated: { request_id } \" , message_text = f \"The request { request_id } has been deleted.\" , ) get_one_request ( request_id ) async Given a Request ID, get the Request object. Source code in sandbox_request/routes/requests.py @request_router . get ( \"/requests/ {request_id} \" , response_model = Request ) async def get_one_request ( request_id ): \"\"\" Given a Request ID, get the Request object. \"\"\" request = await get_request ( request_id ) if not request : raise HTTPException ( status_code = 404 , detail = f \"Request with id ' { request_id } ' not found\" ) return request get_requests () async Retrieve a list of Request objects from the metadata store. Source code in sandbox_request/routes/requests.py @request_router . get ( \"/requests\" , response_model = List [ Request ]) async def get_requests (): \"\"\" Retrieve a list of Request objects from the metadata store. \"\"\" requests = await get_all_requests () return requests update_requests ( request_id , data , config = Depends ( get_config )) async Given a Request ID and data, update the Request object. Source code in sandbox_request/routes/requests.py @request_router . patch ( \"/requests/ {request_id} \" , response_model = Request ) async def update_requests ( request_id , data : RequestPartial , config = Depends ( get_config )): \"\"\" Given a Request ID and data, update the Request object. \"\"\" request = await update_request ( request_id , data ) send_notification ( recipient_name = config . data_requester_name , recipient_email = config . data_requester_email , subject = f \"Request Updated: { request . id } \" , message_text = ( f \"The request { request . id } has been updated to: \\n\\n \" f \"Purpose: { request . purpose } \\n\\n \" f \"Status: { request . status } \" ), ) return request","title":"API routes"},{"location":"reference/routes/#api-routes","text":"This package defines routes/endpoints of the Restful API","title":"API routes"},{"location":"reference/routes/#sandbox_request.routes.health","text":"Health endpoint to check the health of the API","title":"health"},{"location":"reference/routes/#sandbox_request.routes.requests","text":"All routes for interacting with Data Requests.","title":"requests"}]}